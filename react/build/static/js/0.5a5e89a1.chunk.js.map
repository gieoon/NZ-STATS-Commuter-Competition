{"version":3,"sources":["../node_modules/swr/node_modules/fast-deep-equal/index.js","../node_modules/react-use/esm/useUpdateEffect.js","../node_modules/react-use/esm/useFirstMountState.js","../node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../../src/utils/errors.ts","../../src/utils/common.ts","../../src/types/types-internal.ts","../../src/utils/plugins.ts","../../src/core/scope.ts","../../src/core/finalize.ts","../../src/core/proxy.ts","../../src/core/immerClass.ts","../../src/core/current.ts","../../src/immer.ts","../../src/utils/env.ts","../node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js","../node_modules/swr/esm/libs/is-document-visible.js","../node_modules/swr/esm/libs/is-online.js","../node_modules/swr/esm/libs/hash.js","../node_modules/swr/esm/cache.js","../node_modules/swr/esm/config.js","../node_modules/swr/esm/libs/throttle.js","../node_modules/swr/esm/swr-config-context.js","../node_modules/swr/esm/use-swr.js","../node_modules/swr/esm/use-swr-pages.js","../node_modules/swr/esm/index.js"],"names":["isArray","Array","keyList","Object","keys","hasProp","prototype","hasOwnProperty","module","exports","equal","a","b","i","length","key","arrA","arrB","dateA","Date","dateB","getTime","regexpA","RegExp","regexpB","toString","call","useUpdateEffect","effect","deps","isFirstMount","isFirst","useRef","current","useFirstMountState","useEffect","ownKeys","object","enumerableOnly","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread2","target","arguments","source","forEach","getOwnPropertyDescriptors","defineProperties","defineProperty","die","error","args","msg","Error","join","isDraft","value","DRAFT_STATE","isDraftable","proto","getPrototypeOf","DRAFTABLE","constructor","isMap","isSet","each","obj","iter","getArchtype","entry","index","thing","state","type_","has","prop","get","set","propOrOldValue","t","delete","add","is","x","y","hasMap","Map","hasSet","Set","latest","copy_","base_","shallowCopy","base","slice","descriptors","desc","writable","configurable","create","freeze","deep","isFrozen","clear","dontMutateFrozenCollections","getPlugin","pluginKey","plugin","plugins","getCurrentScope","currentScope","usePatchesInScope","scope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","drafts_","revokeDraft","parent_","enterScope","immer","immer_","canAutoFreeze_","unfinalizedDrafts_","draft","revoke_","revoked_","processResult","result","baseDraft","isReplaced","useProxies_","willFinalizeES5_","modified_","finalize","maybeFreeze","generateReplacementPatches_","NOTHING","rootScope","path","childValue","finalizeProperty","scope_","finalized_","draft_","generatePatches_","parentState","targetObject","rootPath","res","assigned_","concat","undefined","autoFreeze_","peek","markChanged","prepareCopy","createProxy","parent","proxyMap_","proxySet_","isManual_","traps","objectTraps","arrayTraps","Proxy","revocable","revoke","proxy","createES5Proxy_","currentImpl","copy","archType","hasChanges_","copyHelper","from","hasSymbol","Symbol","hasProxies","Reflect","iterator","getOwnPropertyNames","deleteProperty","owner","setPrototypeOf","fn","this","e","config","useProxies","setUseProxies","autoFreeze","setAutoFreeze","produce","bind","produceWithPatches","recipe","defaultBase","self","_this","hasError","Promise","then","arg1","arg2","patches","inversePatches","_this2","p","ip","createDraft","finishDraft","applyPatches","patch","op","applyPatchesImpl","applyPatches_","_objectWithoutProperties","excluded","sourceSymbolKeys","indexOf","propertyIsEnumerable","isDocumentVisible","document","visibilityState","isOnline","navigator","onLine","table","WeakMap","counter","cache","Cache","initialData","__cache","entries","__listeners","_key","serializeKey","shouldNotify","mutate","notify","err","_hash","String","hash","subscribe","listener","isSubscribed","_i","_a","CONCURRENT_PROMISES","CONCURRENT_PROMISES_TS","FOCUS_REVALIDATORS","CACHE_REVALIDATORS","MUTATION_TS","slowConnection","window","effectiveType","defaultConfig","onLoadingSlow","onSuccess","onError","onErrorRetry","_","__","revalidate","opts","errorRetryCount","retryCount","count","Math","min","timeout","random","errorRetryInterval","setTimeout","focusThrottleInterval","dedupingInterval","loadingTimeout","refreshInterval","revalidateOnFocus","revalidateOnReconnect","refreshWhenHidden","refreshWhenOffline","shouldRetryOnError","suspense","compare","deepEqual","eventsBinded","addEventListener","throttle","interval","pending","SWRConfigContext","createContext","displayName","__awaiter","thisArg","_arguments","P","generator","resolve","reject","fulfilled","step","next","rejected","done","__generator","body","f","g","label","sent","trys","ops","verb","n","v","TypeError","pop","IS_SERVER","useIsomorphicLayoutEffect","useLayoutEffect","trigger","shouldRevalidate","keyErr","updaters","currentData","currentError","promises","all","broadcastState","data","_data","beforeMutationTs","beforeConcurrentPromisesTs","err_1","err_2","now","Provider","useSWR","fnArgs","assign","useContext","fetcher","initialError","stateDependencies","isValidating","stateRef","rerender","useState","dispatch","useCallback","payload","shouldUpdateState","k","unmountedRef","keyRef","eventsRef","emit","event","params","boundMutate","revalidateOpts","loading","shouldDeduping","newData","startAt","newState","err_3","dedupe","currentHookData","latestKeyedData","onFocus","softRevalidate","revalidateOnMount","onUpdate","updatedData","updatedError","needUpdate","reconnect","revalidators","removeEventListener","timer","tick","clearTimeout","latestData","latestError","useMemo"],"mappings":"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","file":"static/js/0.5a5e89a1.chunk.js","sourcesContent":["'use strict';\n\nvar isArray = Array.isArray;\nvar keyList = Object.keys;\nvar hasProp = Object.prototype.hasOwnProperty;\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    var arrA = isArray(a)\n      , arrB = isArray(b)\n      , i\n      , length\n      , key;\n\n    if (arrA && arrB) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n    if (arrA != arrB) return false;\n\n    var dateA = a instanceof Date\n      , dateB = b instanceof Date;\n    if (dateA != dateB) return false;\n    if (dateA && dateB) return a.getTime() == b.getTime();\n\n    var regexpA = a instanceof RegExp\n      , regexpB = b instanceof RegExp;\n    if (regexpA != regexpB) return false;\n    if (regexpA && regexpB) return a.toString() == b.toString();\n\n    var keys = keyList(a);\n    length = keys.length;\n\n    if (length !== keyList(b).length)\n      return false;\n\n    for (i = length; i-- !== 0;)\n      if (!hasProp.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      key = keys[i];\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  return a!==a && b!==b;\n};\n","/* eslint-disable */\nimport { useEffect } from 'react';\nimport { useFirstMountState } from './useFirstMountState';\nvar useUpdateEffect = function (effect, deps) {\n    var isFirstMount = useFirstMountState();\n    useEffect(function () {\n        if (!isFirstMount) {\n            return effect();\n        }\n    }, deps);\n};\nexport default useUpdateEffect;\n","import { useRef } from 'react';\nexport function useFirstMountState() {\n    var isFirst = useRef(true);\n    if (isFirst.current) {\n        isFirst.current = false;\n        return true;\n    }\n    return isFirst.current;\n}\n","import defineProperty from \"./defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}","const errors = {\n\t0: \"Illegal state\",\n\t1: \"Immer drafts cannot have computed properties\",\n\t2: \"This object has been frozen and should not be mutated\",\n\t3(data: any) {\n\t\treturn (\n\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\tdata\n\t\t)\n\t},\n\t4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t5: \"Immer forbids circular references\",\n\t6: \"The first or second argument to `produce` must be a function\",\n\t7: \"The third argument to `produce` must be a function or undefined\",\n\t8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t10: \"The given draft is already finalized\",\n\t11: \"Object.defineProperty() cannot be used on an Immer draft\",\n\t12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t13: \"Immer only supports deleting array indices\",\n\t14: \"Immer only supports setting array indices and the 'length' property\",\n\t15(path: string) {\n\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t},\n\t16: 'Sets cannot have \"replace\" patches.',\n\t17(op: string) {\n\t\treturn \"Unsupported patch operation: \" + op\n\t},\n\t18(plugin: string) {\n\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t},\n\t19: \"plugin not loaded\",\n\t20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n\t21(thing: string) {\n\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t},\n\t22(thing: string) {\n\t\treturn `'current' expects a draft, got: ${thing}`\n\t},\n\t23(thing: string) {\n\t\treturn `'original' expects a draft, got: ${thing}`\n\t}\n} as const\n\nexport function die(error: keyof typeof errors, ...args: any[]): never {\n\tif (__DEV__) {\n\t\tconst e = errors[error]\n\t\tconst msg = !e\n\t\t\t? \"unknown error nr: \" + error\n\t\t\t: typeof e === \"function\"\n\t\t\t? e.apply(null, args as any)\n\t\t\t: e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}${\n\t\t\targs.length ? \" \" + args.join(\",\") : \"\"\n\t\t}. Find the full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\thasSet,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\thasMap,\n\tArchtypeObject,\n\tArchtypeArray,\n\tArchtypeMap,\n\tArchtypeSet,\n\tdie\n} from \"../internal\"\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = Object.getPrototypeOf(value)\n\treturn !proto || proto === Object.prototype\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(23, value)\n\treturn value[DRAFT_STATE].base_\n}\n\n/*#__PURE__*/\nexport const ownKeys: (target: AnyObject) => PropertyKey[] =\n\ttypeof Reflect !== \"undefined\" && Reflect.ownKeys\n\t\t? Reflect.ownKeys\n\t\t: typeof Object.getOwnPropertySymbols !== \"undefined\"\n\t\t? obj =>\n\t\t\t\tObject.getOwnPropertyNames(obj).concat(\n\t\t\t\t\tObject.getOwnPropertySymbols(obj) as any\n\t\t\t\t)\n\t\t: /* istanbul ignore next */ Object.getOwnPropertyNames\n\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void,\n\tenumerableOnly?: boolean\n): void\nexport function each(obj: any, iter: any, enumerableOnly = false) {\n\tif (getArchtype(obj) === ArchtypeObject) {\n\t\t;(enumerableOnly ? Object.keys : ownKeys)(obj).forEach(key => {\n\t\t\tif (!enumerableOnly || typeof key !== \"symbol\") iter(key, obj[key], obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): 0 | 1 | 2 | 3 {\n\t/* istanbul ignore next */\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_ > 3\n\t\t\t? state.type_ - 4 // cause Object and Array map back from 4 and 5\n\t\t\t: (state.type_ as any) // others are the same\n\t\t: Array.isArray(thing)\n\t\t? ArchtypeArray\n\t\t: isMap(thing)\n\t\t? ArchtypeMap\n\t\t: isSet(thing)\n\t\t? ArchtypeSet\n\t\t: ArchtypeObject\n}\n\n/*#__PURE__*/\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === ArchtypeMap\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n/*#__PURE__*/\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === ArchtypeMap ? thing.get(prop) : thing[prop]\n}\n\n/*#__PURE__*/\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tconst t = getArchtype(thing)\n\tif (t === ArchtypeMap) thing.set(propOrOldValue, value)\n\telse if (t === ArchtypeSet) {\n\t\tthing.delete(propOrOldValue)\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\n/*#__PURE__*/\nexport function isMap(target: any): target is AnyMap {\n\treturn hasMap && target instanceof Map\n}\n\n/*#__PURE__*/\nexport function isSet(target: any): target is AnySet {\n\treturn hasSet && target instanceof Set\n}\n/*#__PURE__*/\nexport function latest(state: ImmerState): any {\n\treturn state.copy_ || state.base_\n}\n\n/*#__PURE__*/\nexport function shallowCopy(base: any) {\n\tif (Array.isArray(base)) return base.slice()\n\tconst descriptors = Object.getOwnPropertyDescriptors(base)\n\tdelete descriptors[DRAFT_STATE as any]\n\tfor (let key in descriptors) {\n\t\tconst desc = descriptors[key]\n\t\tif (desc.writable === false) {\n\t\t\tdesc.writable = true\n\t\t\tdesc.configurable = true\n\t\t}\n\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t// with libraries that trap values, like mobx or vue\n\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\tif (desc.get || desc.set)\n\t\t\tdescriptors[key] = {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true, // could live with !!desc.set as well here...\n\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\tvalue: base[key]\n\t\t\t}\n\t}\n\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n}\n\nexport function freeze(obj: any, deep: boolean): void {\n\tif (Object.isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tobj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any\n\t}\n\tObject.freeze(obj)\n\tif (deep) each(obj, (key, value) => freeze(value, true), true)\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nexport function isFrozen(obj: any): boolean {\n\tif (obj == null || typeof obj !== \"object\") return true\n\t// See #600, IE dies on non-objects in Object.isFrozen\n\treturn Object.isFrozen(obj)\n}\n","import {\n\tSetState,\n\tImmerScope,\n\tProxyObjectState,\n\tProxyArrayState,\n\tES5ObjectState,\n\tES5ArrayState,\n\tMapState,\n\tDRAFT_STATE\n} from \"../internal\"\n\nexport type Objectish = AnyObject | AnyArray | AnyMap | AnySet\nexport type ObjectishNoSet = AnyObject | AnyArray | AnyMap\n\nexport type AnyObject = {[key: string]: any}\nexport type AnyArray = Array<any>\nexport type AnySet = Set<any>\nexport type AnyMap = Map<any, any>\n\nexport const ArchtypeObject = 0\nexport const ArchtypeArray = 1\nexport const ArchtypeMap = 2\nexport const ArchtypeSet = 3\n\nexport const ProxyTypeProxyObject = 0\nexport const ProxyTypeProxyArray = 1\nexport const ProxyTypeES5Object = 4\nexport const ProxyTypeES5Array = 5\nexport const ProxyTypeMap = 2\nexport const ProxyTypeSet = 3\n\nexport interface ImmerBaseState {\n\tparent_?: ImmerState\n\tscope_: ImmerScope\n\tmodified_: boolean\n\tfinalized_: boolean\n\tisManual_: boolean\n}\n\nexport type ImmerState =\n\t| ProxyObjectState\n\t| ProxyArrayState\n\t| ES5ObjectState\n\t| ES5ArrayState\n\t| MapState\n\t| SetState\n\n// The _internal_ type used for drafts (not to be confused with Draft, which is public facing)\nexport type Drafted<Base = any, T extends ImmerState = ImmerState> = {\n\t[DRAFT_STATE]: T\n} & Base\n","import {\n\tImmerState,\n\tPatch,\n\tImmerScope,\n\tDrafted,\n\tAnyObject,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tProxyTypeES5Array,\n\tProxyTypeES5Object,\n\tProxyTypeMap,\n\tProxyTypeSet,\n\tdie\n} from \"../internal\"\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: {\n\t\tgeneratePatches_(\n\t\t\tstate: ImmerState,\n\t\t\tbasePath: PatchPath,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tgenerateReplacementPatches_(\n\t\t\trootState: ImmerState,\n\t\t\treplacement: any,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tapplyPatches_<T>(draft: T, patches: Patch[]): T\n\t}\n\tES5?: {\n\t\twillFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean): void\n\t\tcreateES5Proxy_<T>(\n\t\t\tbase: T,\n\t\t\tparent?: ImmerState\n\t\t): Drafted<T, ES5ObjectState | ES5ArrayState>\n\t\thasChanges_(state: ES5ArrayState | ES5ObjectState): boolean\n\t}\n\tMapSet?: {\n\t\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\n\t\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\n\t}\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(__DEV__ ? 18 : 19, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tplugins[pluginKey] = implementation\n}\n\n/** ES5 Plugin */\n\ninterface ES5BaseState extends ImmerBaseState {\n\tassigned_: {[key: string]: any}\n\tparent_?: ImmerState\n\trevoked_: boolean\n}\n\nexport interface ES5ObjectState extends ES5BaseState {\n\ttype_: typeof ProxyTypeES5Object\n\tdraft_: Drafted<AnyObject, ES5ObjectState>\n\tbase_: AnyObject\n\tcopy_: AnyObject | null\n}\n\nexport interface ES5ArrayState extends ES5BaseState {\n\ttype_: typeof ProxyTypeES5Array\n\tdraft_: Drafted<AnyObject, ES5ArrayState>\n\tbase_: any\n\tcopy_: any\n}\n\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: typeof ProxyTypeMap\n\tcopy_: AnyMap | undefined\n\tassigned_: Map<any, boolean> | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: typeof ProxyTypeSet\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tProxyTypeProxyObject,\n\tProxyTypeProxyArray,\n\tgetPlugin\n} from \"../internal\"\nimport {die} from \"../utils/errors\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport function getCurrentScope() {\n\tif (__DEV__ && !currentScope) die(0)\n\treturn currentScope!\n}\n\nfunction createScope(\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope {\n\treturn {\n\t\tdrafts_: [],\n\t\tparent_,\n\t\timmer_,\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tcanAutoFreeze_: true,\n\t\tunfinalizedDrafts_: 0\n\t}\n}\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tgetPlugin(\"Patches\") // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport function enterScope(immer: Immer) {\n\treturn (currentScope = createScope(currentScope, immer))\n}\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (\n\t\tstate.type_ === ProxyTypeProxyObject ||\n\t\tstate.type_ === ProxyTypeProxyArray\n\t)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n","import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\thas,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tProxyTypeES5Object,\n\tProxyTypeES5Array,\n\tProxyTypeSet,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen,\n\tshallowCopy\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\tif (!scope.immer_.useProxies_)\n\t\tgetPlugin(\"ES5\").willFinalizeES5_(scope, result, isReplaced)\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t\tif (!scope.parent_) maybeFreeze(scope, result)\n\t\t}\n\t\tif (scope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE],\n\t\t\t\tresult,\n\t\t\t\tscope.patches_,\n\t\t\t\tscope.inversePatches_!\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft, [])\n\t}\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\t// A plain object, might need freezing, might contain drafts\n\tif (!state) {\n\t\teach(\n\t\t\tvalue,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, value, key, childValue, path),\n\t\t\ttrue // See #590, don't recurse into non-enumarable of non drafted objects\n\t\t)\n\t\treturn value\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope_ !== rootScope) return value\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\tmaybeFreeze(rootScope, state.base_, true)\n\t\treturn state.base_\n\t}\n\t// Not finalized yet, let's do that now\n\tif (!state.finalized_) {\n\t\tstate.finalized_ = true\n\t\tstate.scope_.unfinalizedDrafts_--\n\t\tconst result =\n\t\t\t// For ES5, create a good copy from the draft first, with added keys and without deleted keys.\n\t\t\tstate.type_ === ProxyTypeES5Object || state.type_ === ProxyTypeES5Array\n\t\t\t\t? (state.copy_ = shallowCopy(state.draft_))\n\t\t\t\t: state.copy_\n\t\t// finalize all children of the copy\n\t\teach(result as any, (key, childValue) =>\n\t\t\tfinalizeProperty(rootScope, state, result, key, childValue, path)\n\t\t)\n\t\t// everything inside is frozen, we can freeze here\n\t\tmaybeFreeze(rootScope, result, false)\n\t\t// first time finalizing, let's create those patches\n\t\tif (path && rootScope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generatePatches_(\n\t\t\t\tstate,\n\t\t\t\tpath,\n\t\t\t\trootScope.patches_,\n\t\t\t\trootScope.inversePatches_!\n\t\t\t)\n\t\t}\n\t}\n\treturn state.copy_\n}\n\nfunction finalizeProperty(\n\trootScope: ImmerScope,\n\tparentState: undefined | ImmerState,\n\ttargetObject: any,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath\n) {\n\tif (__DEV__ && childValue === targetObject) die(5)\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tparentState &&\n\t\t\tparentState!.type_ !== ProxyTypeSet && // Set objects are atomic since they have no keys.\n\t\t\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tconst res = finalize(rootScope, childValue, path)\n\t\tset(targetObject, prop, res)\n\t\t// Drafts from another scope must prevented to be frozen\n\t\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n\t\tif (isDraft(res)) {\n\t\t\trootScope.canAutoFreeze_ = false\n\t\t} else return\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\tif (isDraftable(childValue) && !Object.isFrozen(childValue)) {\n\t\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t\t// This benefits especially adding large data tree's without further processing.\n\t\t\t// See add-data.js perf test\n\t\t\treturn\n\t\t}\n\t\tfinalize(rootScope, childValue)\n\t\t// immer deep freezes plain objects, so if there is no parent state, we freeze as well\n\t\tif (!parentState || !parentState.scope_.parent_)\n\t\t\tmaybeFreeze(rootScope, childValue)\n\t}\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\tif (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n","import {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tProxyTypeProxyObject,\n\tProxyTypeProxyArray\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned_: {\n\t\t[property: string]: boolean\n\t}\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: typeof ProxyTypeProxyObject\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: typeof ProxyTypeProxyArray\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: isArray ? ProxyTypeProxyArray : (ProxyTypeProxyObject as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned_: {},\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\treturn (state.copy_![prop as any] = createProxy(\n\t\t\t\tstate.scope_.immer_,\n\t\t\t\tvalue,\n\t\t\t\tstate\n\t\t\t))\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(state, prop: string /* strictly not, but helps TS */, value) {\n\t\tstate.assigned_[prop] = true\n\t\tif (!state.modified_) {\n\t\t\tif (is(value, peek(latest(state), prop)) && value !== undefined)\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned_[prop]\n\t\t}\n\t\t// @ts-ignore\n\t\tif (state.copy_) delete state.copy_[prop]\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\twritable: true,\n\t\t\tconfigurable: state.type_ !== ProxyTypeProxyArray || prop !== \"length\",\n\t\t\tenumerable: desc.enumerable,\n\t\t\tvalue: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn Object.getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (__DEV__ && isNaN(parseInt(prop as any))) die(13)\n\treturn objectTraps.deleteProperty!.call(this, state[0], prop)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (__DEV__ && prop !== \"length\" && isNaN(parseInt(prop as any))) die(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = Object.getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\t// This is a very special case, if the prop is a getter defined by the\n\t\t// prototype, we should invoke it with the draft as context!\n\t\tif (desc) return `value` in desc ? desc.value : desc.get?.call(state.draft_)\n\t\tproto = Object.getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: {base_: any; copy_: any}) {\n\tif (!state.copy_) {\n\t\tstate.copy_ = shallowCopy(state.base_)\n\t}\n}\n","import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\thasProxies,\n\tisMinified,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport class Immer implements ProducersFns {\n\tuseProxies_: boolean = hasProxies\n\n\tautoFreeze_: boolean = __DEV__ ? true /* istanbul ignore next */ : !isMinified\n\n\tconstructor(config?: {useProxies?: boolean; autoFreeze?: boolean}) {\n\t\tif (typeof config?.useProxies === \"boolean\")\n\t\t\tthis.setUseProxies(config!.useProxies)\n\t\tif (typeof config?.autoFreeze === \"boolean\")\n\t\t\tthis.setAutoFreeze(config!.autoFreeze)\n\t\tthis.produce = this.produce.bind(this)\n\t\tthis.produceWithPatches = this.produceWithPatches.bind(this)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce(base: any, recipe?: any, patchListener?: any) {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (typeof recipe !== \"function\") die(6)\n\t\tif (patchListener !== undefined && typeof patchListener !== \"function\")\n\t\t\tdie(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(this, base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\t\treturn result.then(\n\t\t\t\t\tresult => {\n\t\t\t\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\t\t\t\treturn processResult(result, scope)\n\t\t\t\t\t},\n\t\t\t\t\terror => {\n\t\t\t\t\t\trevokeScope(scope)\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || typeof base !== \"object\") {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === NOTHING) return undefined\n\t\t\tif (result === undefined) result = base\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\treturn result\n\t\t} else die(21, base)\n\t}\n\n\tproduceWithPatches(arg1: any, arg2?: any, arg3?: any): any {\n\t\tif (typeof arg1 === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => arg1(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst nextState = this.produce(arg1, arg2, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\t\treturn [nextState, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(this, base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (__DEV__) {\n\t\t\tif (!state || !state.isManual_) die(9)\n\t\t\tif (state.finalized_) die(10)\n\t\t}\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is disabled in production.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n\t * always faster than using ES5 proxies.\n\t *\n\t * By default, feature detection is used, so calling this is rarely necessary.\n\t */\n\tsetUseProxies(value: boolean) {\n\t\tif (value && !hasProxies) {\n\t\t\tdie(20)\n\t\t}\n\t\tthis.useProxies_ = value\n\t}\n\n\tapplyPatches(base: Objectish, patches: Patch[]) {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(\"Patches\").applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches.slice(i + 1))\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\timmer: Immer,\n\tvalue: T,\n\tparent?: ImmerState\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\tconst draft: Drafted = isMap(value)\n\t\t? getPlugin(\"MapSet\").proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(\"MapSet\").proxySet_(value, parent)\n\t\t: immer.useProxies_\n\t\t? createProxyProxy(value, parent)\n\t\t: getPlugin(\"ES5\").createES5Proxy_(value, parent)\n\n\tconst scope = parent ? parent.scope_ : getCurrentScope()\n\tscope.drafts_.push(draft)\n\treturn draft\n}\n","import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tget,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tArchtypeMap,\n\tArchtypeSet,\n\tgetArchtype,\n\tgetPlugin\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(22, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tconst archType = getArchtype(value)\n\tif (state) {\n\t\tif (\n\t\t\t!state.modified_ &&\n\t\t\t(state.type_ < 4 || !getPlugin(\"ES5\").hasChanges_(state as any))\n\t\t)\n\t\t\treturn state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = copyHelper(value, archType)\n\t\tstate.finalized_ = false\n\t} else {\n\t\tcopy = copyHelper(value, archType)\n\t}\n\n\teach(copy, (key, childValue) => {\n\t\tif (state && get(state.base_, key) === childValue) return // no need to copy or search in something that didn't change\n\t\tset(copy, key, currentImpl(childValue))\n\t})\n\t// In the future, we might consider freezing here, based on the current settings\n\treturn archType === ArchtypeSet ? new Set(copy) : copy\n}\n\nfunction copyHelper(value: any, archType: number): any {\n\t// creates a shallow copy, even if it is a map or set\n\tswitch (archType) {\n\t\tcase ArchtypeMap:\n\t\t\treturn new Map(value)\n\t\tcase ArchtypeSet:\n\t\t\t// Set will be cloned as array temporarily, so that we can replace individual items\n\t\t\treturn Array.from(value)\n\t}\n\treturn shallowCopy(value)\n}\n","import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\nexport default produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * By default, auto-freezing is disabled in production.\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nexport const setUseProxies = immer.setUseProxies.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\nexport {Immer}\n\nexport {enableES5} from \"./plugins/es5\"\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\nexport {enableAllPlugins} from \"./plugins/all\"\n","// Should be no imports here!\n\n// Some things that should be evaluated before all else...\n\n// We only want to know if non-polyfilled symbols are available\nconst hasSymbol =\n\ttypeof Symbol !== \"undefined\" && typeof Symbol(\"x\") === \"symbol\"\nexport const hasMap = typeof Map !== \"undefined\"\nexport const hasSet = typeof Set !== \"undefined\"\nexport const hasProxies =\n\ttypeof Proxy !== \"undefined\" &&\n\ttypeof Proxy.revocable !== \"undefined\" &&\n\ttypeof Reflect !== \"undefined\"\n\n/* istanbul ignore next */\nfunction mini() {}\nexport const isMinified = mini.name !== \"mini\"\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: Nothing = hasSymbol\n\t? Symbol(\"immer-nothing\")\n\t: ({[\"immer-nothing\"]: true} as any)\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = hasSymbol\n\t? Symbol(\"immer-draftable\")\n\t: (\"__$immer_draftable\" as any)\n\nexport const DRAFT_STATE: unique symbol = hasSymbol\n\t? Symbol(\"immer-state\")\n\t: (\"__$immer_state\" as any)\n\n// Even a polyfilled Symbol might provide Symbol.iterator\nexport const iteratorSymbol: typeof Symbol.iterator =\n\t(typeof Symbol != \"undefined\" && Symbol.iterator) || (\"@@iterator\" as any)\n\n/** Use a class type for `nothing` so its type is unique */\nexport class Nothing {\n\t// This lets us do `Exclude<T, Nothing>`\n\t// @ts-ignore\n\tprivate _!: unique symbol\n}\n","import objectWithoutPropertiesLoose from \"./objectWithoutPropertiesLoose\";\nexport default function _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}","export default function isDocumentVisible() {\n    if (typeof document !== 'undefined' &&\n        typeof document.visibilityState !== 'undefined') {\n        return document.visibilityState !== 'hidden';\n    }\n    // always assume it's visible\n    return true;\n}\n","export default function isOnline() {\n    if (typeof navigator.onLine !== 'undefined') {\n        return navigator.onLine;\n    }\n    // always assume it's online\n    return true;\n}\n","// use WeakMap to store the object->key mapping\n// so the objects can be garbage collected.\n// WeakMap uses a hashtable under the hood, so the lookup\n// complexity is almost O(1).\nvar table = new WeakMap();\n// counter of the key\nvar counter = 0;\n// hashes an array of objects and returns a string\nexport default function hash(args) {\n    if (!args.length)\n        return '';\n    var key = 'arg';\n    for (var i = 0; i < args.length; ++i) {\n        var _hash = void 0;\n        if (args[i] === null || typeof args[i] !== 'object') {\n            // need to consider the case that args[i] is a string:\n            // args[i]        _hash\n            // \"undefined\" -> '\"undefined\"'\n            // undefined   -> 'undefined'\n            // 123         -> '123'\n            // null        -> 'null'\n            // \"null\"      -> '\"null\"'\n            if (typeof args[i] === 'string') {\n                _hash = '\"' + args[i] + '\"';\n            }\n            else {\n                _hash = String(args[i]);\n            }\n        }\n        else {\n            if (!table.has(args[i])) {\n                _hash = counter;\n                table.set(args[i], counter++);\n            }\n            else {\n                _hash = table.get(args[i]);\n            }\n        }\n        key += '@' + _hash;\n    }\n    return key;\n}\n","import { mutate } from './use-swr';\nimport hash from './libs/hash';\nvar Cache = /** @class */ (function () {\n    function Cache(initialData) {\n        if (initialData === void 0) { initialData = {}; }\n        this.__cache = new Map(Object.entries(initialData));\n        this.__listeners = [];\n    }\n    Cache.prototype.get = function (key) {\n        var _key = this.serializeKey(key)[0];\n        return this.__cache.get(_key);\n    };\n    Cache.prototype.set = function (key, value, shouldNotify) {\n        if (shouldNotify === void 0) { shouldNotify = true; }\n        var _key = this.serializeKey(key)[0];\n        this.__cache.set(_key, value);\n        if (shouldNotify)\n            mutate(key, value, false);\n        this.notify();\n    };\n    Cache.prototype.keys = function () {\n        return Array.from(this.__cache.keys());\n    };\n    Cache.prototype.has = function (key) {\n        var _key = this.serializeKey(key)[0];\n        return this.__cache.has(_key);\n    };\n    Cache.prototype.clear = function (shouldNotify) {\n        if (shouldNotify === void 0) { shouldNotify = true; }\n        if (shouldNotify)\n            this.__cache.forEach(function (key) { return mutate(key, null, false); });\n        this.__cache.clear();\n        this.notify();\n    };\n    Cache.prototype.delete = function (key, shouldNotify) {\n        if (shouldNotify === void 0) { shouldNotify = true; }\n        var _key = this.serializeKey(key)[0];\n        if (shouldNotify)\n            mutate(key, null, false);\n        this.__cache.delete(_key);\n        this.notify();\n    };\n    // TODO: introduce namespace for the cache\n    Cache.prototype.serializeKey = function (key) {\n        var args = null;\n        if (typeof key === 'function') {\n            try {\n                key = key();\n            }\n            catch (err) {\n                // dependencies not ready\n                key = '';\n            }\n        }\n        if (Array.isArray(key)) {\n            // args array\n            args = key;\n            key = hash(key);\n        }\n        else {\n            // convert null to ''\n            key = String(key || '');\n        }\n        var errorKey = key ? 'err@' + key : '';\n        return [key, args, errorKey];\n    };\n    Cache.prototype.subscribe = function (listener) {\n        var _this = this;\n        if (typeof listener !== 'function') {\n            throw new Error('Expected the listener to be a function.');\n        }\n        var isSubscribed = true;\n        this.__listeners.push(listener);\n        return function () {\n            if (!isSubscribed)\n                return;\n            isSubscribed = false;\n            var index = _this.__listeners.indexOf(listener);\n            if (index > -1) {\n                _this.__listeners[index] = _this.__listeners[_this.__listeners.length - 1];\n                _this.__listeners.length--;\n            }\n        };\n    };\n    // Notify Cache subscribers about a change in the cache\n    Cache.prototype.notify = function () {\n        for (var _i = 0, _a = this.__listeners; _i < _a.length; _i++) {\n            var listener = _a[_i];\n            listener();\n        }\n    };\n    return Cache;\n}());\nexport default Cache;\n","import deepEqual from 'fast-deep-equal';\nimport isDocumentVisible from './libs/is-document-visible';\nimport isOnline from './libs/is-online';\nimport Cache from './cache';\n// cache\nvar cache = new Cache();\n// state managers\nvar CONCURRENT_PROMISES = {};\nvar CONCURRENT_PROMISES_TS = {};\nvar FOCUS_REVALIDATORS = {};\nvar CACHE_REVALIDATORS = {};\nvar MUTATION_TS = {};\n// error retry\nfunction onErrorRetry(_, __, config, revalidate, opts) {\n    if (!isDocumentVisible()) {\n        // if it's hidden, stop\n        // it will auto revalidate when focus\n        return;\n    }\n    if (config.errorRetryCount && opts.retryCount > config.errorRetryCount) {\n        return;\n    }\n    // exponential backoff\n    var count = Math.min(opts.retryCount || 0, 8);\n    var timeout = ~~((Math.random() + 0.5) * (1 << count)) * config.errorRetryInterval;\n    setTimeout(revalidate, timeout, opts);\n}\n// client side: need to adjust the config\n// based on the browser status\n// slow connection (<= 70Kbps)\nvar slowConnection = typeof window !== 'undefined' &&\n    navigator['connection'] &&\n    ['slow-2g', '2g'].indexOf(navigator['connection'].effectiveType) !== -1;\n// config\nvar defaultConfig = {\n    // events\n    onLoadingSlow: function () { },\n    onSuccess: function () { },\n    onError: function () { },\n    onErrorRetry: onErrorRetry,\n    errorRetryInterval: (slowConnection ? 10 : 5) * 1000,\n    focusThrottleInterval: 5 * 1000,\n    dedupingInterval: 2 * 1000,\n    loadingTimeout: (slowConnection ? 5 : 3) * 1000,\n    refreshInterval: 0,\n    revalidateOnFocus: true,\n    revalidateOnReconnect: true,\n    refreshWhenHidden: false,\n    refreshWhenOffline: false,\n    shouldRetryOnError: true,\n    suspense: false,\n    compare: deepEqual\n};\n// Focus revalidate\nvar eventsBinded = false;\nif (typeof window !== 'undefined' && window.addEventListener && !eventsBinded) {\n    var revalidate = function () {\n        if (!isDocumentVisible() || !isOnline())\n            return;\n        for (var key in FOCUS_REVALIDATORS) {\n            if (FOCUS_REVALIDATORS[key][0])\n                FOCUS_REVALIDATORS[key][0]();\n        }\n    };\n    window.addEventListener('visibilitychange', revalidate, false);\n    window.addEventListener('focus', revalidate, false);\n    // only bind the events once\n    eventsBinded = true;\n}\nexport { CONCURRENT_PROMISES, CONCURRENT_PROMISES_TS, FOCUS_REVALIDATORS, CACHE_REVALIDATORS, MUTATION_TS, cache };\nexport default defaultConfig;\n","export default function throttle(fn, interval) {\n    var pending = false;\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (pending)\n            return;\n        pending = true;\n        fn.apply(void 0, args);\n        setTimeout(function () { return (pending = false); }, interval);\n    };\n}\n","import { createContext } from 'react';\nvar SWRConfigContext = createContext({});\nSWRConfigContext.displayName = 'SWRConfigContext';\nexport default SWRConfigContext;\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { useCallback, useContext, useEffect, useLayoutEffect, useState, useRef, useMemo } from 'react';\nimport defaultConfig, { CACHE_REVALIDATORS, CONCURRENT_PROMISES, CONCURRENT_PROMISES_TS, FOCUS_REVALIDATORS, MUTATION_TS, cache } from './config';\nimport isDocumentVisible from './libs/is-document-visible';\nimport isOnline from './libs/is-online';\nimport throttle from './libs/throttle';\nimport SWRConfigContext from './swr-config-context';\nvar IS_SERVER = typeof window === 'undefined';\n// React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\nvar useIsomorphicLayoutEffect = IS_SERVER ? useEffect : useLayoutEffect;\nvar trigger = function (_key, shouldRevalidate) {\n    if (shouldRevalidate === void 0) { shouldRevalidate = true; }\n    // we are ignoring the second argument which correspond to the arguments\n    // the fetcher will receive when key is an array\n    var _a = cache.serializeKey(_key), key = _a[0], keyErr = _a[2];\n    if (!key)\n        return Promise.resolve();\n    var updaters = CACHE_REVALIDATORS[key];\n    if (key && updaters) {\n        var currentData = cache.get(key);\n        var currentError = cache.get(keyErr);\n        var promises = [];\n        for (var i = 0; i < updaters.length; ++i) {\n            promises.push(updaters[i](shouldRevalidate, currentData, currentError, i > 0));\n        }\n        // return new updated value\n        return Promise.all(promises).then(function () { return cache.get(key); });\n    }\n    return Promise.resolve(cache.get(key));\n};\nvar broadcastState = function (key, data, error) {\n    var updaters = CACHE_REVALIDATORS[key];\n    if (key && updaters) {\n        for (var i = 0; i < updaters.length; ++i) {\n            updaters[i](false, data, error);\n        }\n    }\n};\nvar mutate = function (_key, _data, shouldRevalidate) {\n    if (shouldRevalidate === void 0) { shouldRevalidate = true; }\n    return __awaiter(void 0, void 0, void 0, function () {\n        var key, data, error, beforeMutationTs, beforeConcurrentPromisesTs, err_1, err_2, updaters, promises, i;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    key = cache.serializeKey(_key)[0];\n                    if (!key)\n                        return [2 /*return*/];\n                    // if there is no new data, call revalidate against the key\n                    if (typeof _data === 'undefined')\n                        return [2 /*return*/, trigger(_key, shouldRevalidate)\n                            // update timestamp\n                        ];\n                    // update timestamp\n                    MUTATION_TS[key] = Date.now() - 1;\n                    beforeMutationTs = MUTATION_TS[key];\n                    beforeConcurrentPromisesTs = CONCURRENT_PROMISES_TS[key];\n                    if (!(_data && typeof _data === 'function')) return [3 /*break*/, 5];\n                    _a.label = 1;\n                case 1:\n                    _a.trys.push([1, 3, , 4]);\n                    return [4 /*yield*/, _data(cache.get(key))];\n                case 2:\n                    data = _a.sent();\n                    return [3 /*break*/, 4];\n                case 3:\n                    err_1 = _a.sent();\n                    error = err_1;\n                    return [3 /*break*/, 4];\n                case 4: return [3 /*break*/, 11];\n                case 5:\n                    if (!(_data && typeof _data.then === 'function')) return [3 /*break*/, 10];\n                    _a.label = 6;\n                case 6:\n                    _a.trys.push([6, 8, , 9]);\n                    return [4 /*yield*/, _data];\n                case 7:\n                    data = _a.sent();\n                    return [3 /*break*/, 9];\n                case 8:\n                    err_2 = _a.sent();\n                    error = err_2;\n                    return [3 /*break*/, 9];\n                case 9: return [3 /*break*/, 11];\n                case 10:\n                    data = _data;\n                    _a.label = 11;\n                case 11:\n                    // Check if other mutations have occurred since we've started awaiting, if so then do not persist this change\n                    if (beforeMutationTs !== MUTATION_TS[key] ||\n                        beforeConcurrentPromisesTs !== CONCURRENT_PROMISES_TS[key]) {\n                        if (error)\n                            throw error;\n                        return [2 /*return*/, data];\n                    }\n                    if (typeof data !== 'undefined') {\n                        // update cached data, avoid notifying from the cache\n                        cache.set(key, data, false);\n                    }\n                    updaters = CACHE_REVALIDATORS[key];\n                    if (updaters) {\n                        promises = [];\n                        for (i = 0; i < updaters.length; ++i) {\n                            promises.push(updaters[i](!!shouldRevalidate, data, error, i > 0));\n                        }\n                        // return new updated value\n                        return [2 /*return*/, Promise.all(promises).then(function () { return cache.get(key); })];\n                    }\n                    // throw error or return data to be used by caller of mutate\n                    if (error)\n                        throw error;\n                    return [2 /*return*/, data];\n            }\n        });\n    });\n};\nfunction useSWR() {\n    var _this = this;\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var _key, fn, config = {};\n    if (args.length >= 1) {\n        _key = args[0];\n    }\n    if (args.length > 2) {\n        fn = args[1];\n        config = args[2];\n    }\n    else {\n        if (typeof args[1] === 'function') {\n            fn = args[1];\n        }\n        else if (typeof args[1] === 'object') {\n            config = args[1];\n        }\n    }\n    // we assume `key` as the identifier of the request\n    // `key` can change but `fn` shouldn't\n    // (because `revalidate` only depends on `key`)\n    // `keyErr` is the cache key for error objects\n    var _a = cache.serializeKey(_key), key = _a[0], fnArgs = _a[1], keyErr = _a[2];\n    config = Object.assign({}, defaultConfig, useContext(SWRConfigContext), config);\n    if (typeof fn === 'undefined') {\n        // use a global fetcher\n        fn = config.fetcher;\n    }\n    var initialData = cache.get(key) || config.initialData;\n    var initialError = cache.get(keyErr);\n    // if a state is accessed (data, error or isValidating),\n    // we add the state to dependencies so if the state is\n    // updated in the future, we can trigger a rerender\n    var stateDependencies = useRef({\n        data: false,\n        error: false,\n        isValidating: false\n    });\n    var stateRef = useRef({\n        data: initialData,\n        error: initialError,\n        isValidating: false\n    });\n    var rerender = useState(null)[1];\n    var dispatch = useCallback(function (payload) {\n        var shouldUpdateState = false;\n        for (var k in payload) {\n            stateRef.current[k] = payload[k];\n            if (stateDependencies.current[k]) {\n                shouldUpdateState = true;\n            }\n        }\n        if (shouldUpdateState || config.suspense) {\n            rerender({});\n        }\n    }, []);\n    // error ref inside revalidate (is last request errored?)\n    var unmountedRef = useRef(false);\n    var keyRef = useRef(key);\n    // do unmount check for callbacks\n    var eventsRef = useRef({\n        emit: function (event) {\n            var params = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                params[_i - 1] = arguments[_i];\n            }\n            if (unmountedRef.current)\n                return;\n            config[event].apply(config, params);\n        }\n    });\n    var boundMutate = useCallback(function (data, shouldRevalidate) {\n        return mutate(key, data, shouldRevalidate);\n    }, [key]);\n    // start a revalidation\n    var revalidate = useCallback(function (revalidateOpts) {\n        if (revalidateOpts === void 0) { revalidateOpts = {}; }\n        return __awaiter(_this, void 0, void 0, function () {\n            var loading, shouldDeduping, newData, startAt, newState, err_3, retryCount;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!key || !fn)\n                            return [2 /*return*/, false];\n                        if (unmountedRef.current)\n                            return [2 /*return*/, false];\n                        revalidateOpts = Object.assign({ dedupe: false }, revalidateOpts);\n                        loading = true;\n                        shouldDeduping = typeof CONCURRENT_PROMISES[key] !== 'undefined' && revalidateOpts.dedupe;\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 6, , 7]);\n                        dispatch({\n                            isValidating: true\n                        });\n                        newData = void 0;\n                        startAt = void 0;\n                        if (!shouldDeduping) return [3 /*break*/, 3];\n                        // there's already an ongoing request,\n                        // this one needs to be deduplicated.\n                        startAt = CONCURRENT_PROMISES_TS[key];\n                        return [4 /*yield*/, CONCURRENT_PROMISES[key]];\n                    case 2:\n                        newData = _a.sent();\n                        return [3 /*break*/, 5];\n                    case 3:\n                        // if not deduping the request (hard revalidate) but\n                        // there're other ongoing request(s) at the same time,\n                        // we need to ignore the other result(s) to avoid\n                        // possible race conditions:\n                        // req1------------------>res1\n                        //      req2-------->res2\n                        // in that case, the second response should not be overridden\n                        // by the first one.\n                        if (CONCURRENT_PROMISES[key]) {\n                            // we can mark it as a mutation to ignore\n                            // all requests which are fired before this one\n                            MUTATION_TS[key] = Date.now() - 1;\n                        }\n                        // if no cache being rendered currently (it shows a blank page),\n                        // we trigger the loading slow event.\n                        if (config.loadingTimeout && !cache.get(key)) {\n                            setTimeout(function () {\n                                if (loading)\n                                    eventsRef.current.emit('onLoadingSlow', key, config);\n                            }, config.loadingTimeout);\n                        }\n                        if (fnArgs !== null) {\n                            CONCURRENT_PROMISES[key] = fn.apply(void 0, fnArgs);\n                        }\n                        else {\n                            CONCURRENT_PROMISES[key] = fn(key);\n                        }\n                        CONCURRENT_PROMISES_TS[key] = startAt = Date.now();\n                        return [4 /*yield*/, CONCURRENT_PROMISES[key]];\n                    case 4:\n                        newData = _a.sent();\n                        setTimeout(function () {\n                            delete CONCURRENT_PROMISES[key];\n                            delete CONCURRENT_PROMISES_TS[key];\n                        }, config.dedupingInterval);\n                        // trigger the success event,\n                        // only do this for the original request.\n                        eventsRef.current.emit('onSuccess', newData, key, config);\n                        _a.label = 5;\n                    case 5:\n                        // if the revalidation happened earlier than the local mutation,\n                        // we have to ignore the result because it could override.\n                        // meanwhile, a new revalidation should be triggered by the mutation.\n                        if (MUTATION_TS[key] && startAt <= MUTATION_TS[key]) {\n                            dispatch({ isValidating: false });\n                            return [2 /*return*/, false];\n                        }\n                        cache.set(key, newData, false);\n                        cache.set(keyErr, undefined, false);\n                        newState = {\n                            isValidating: false\n                        };\n                        if (typeof stateRef.current.error !== 'undefined') {\n                            // we don't have an error\n                            newState.error = undefined;\n                        }\n                        if (!config.compare(stateRef.current.data, newData)) {\n                            // deep compare to avoid extra re-render\n                            // data changed\n                            newState.data = newData;\n                        }\n                        // merge the new state\n                        dispatch(newState);\n                        if (!shouldDeduping) {\n                            // also update other hooks\n                            broadcastState(key, newData, undefined);\n                        }\n                        return [3 /*break*/, 7];\n                    case 6:\n                        err_3 = _a.sent();\n                        delete CONCURRENT_PROMISES[key];\n                        delete CONCURRENT_PROMISES_TS[key];\n                        cache.set(keyErr, err_3, false);\n                        // get a new error\n                        // don't use deep equal for errors\n                        if (stateRef.current.error !== err_3) {\n                            // we keep the stale data\n                            dispatch({\n                                isValidating: false,\n                                error: err_3\n                            });\n                            if (!shouldDeduping) {\n                                // also broadcast to update other hooks\n                                broadcastState(key, undefined, err_3);\n                            }\n                        }\n                        // events and retry\n                        eventsRef.current.emit('onError', err_3, key, config);\n                        if (config.shouldRetryOnError) {\n                            retryCount = (revalidateOpts.retryCount || 0) + 1;\n                            eventsRef.current.emit('onErrorRetry', err_3, key, config, revalidate, Object.assign({ dedupe: true }, revalidateOpts, { retryCount: retryCount }));\n                        }\n                        return [3 /*break*/, 7];\n                    case 7:\n                        loading = false;\n                        return [2 /*return*/, true];\n                }\n            });\n        });\n    }, [key]);\n    // mounted (client side rendering)\n    useIsomorphicLayoutEffect(function () {\n        if (!key)\n            return undefined;\n        // after `key` updates, we need to mark it as mounted\n        unmountedRef.current = false;\n        // after the component is mounted (hydrated),\n        // we need to update the data from the cache\n        // and trigger a revalidation\n        var currentHookData = stateRef.current.data;\n        var latestKeyedData = cache.get(key) || config.initialData;\n        // update the state if the key changed (not the inital render) or cache updated\n        if (keyRef.current !== key ||\n            !config.compare(currentHookData, latestKeyedData)) {\n            dispatch({ data: latestKeyedData });\n            keyRef.current = key;\n        }\n        // revalidate with deduping\n        var softRevalidate = function () { return revalidate({ dedupe: true }); };\n        // trigger a revalidation\n        if (config.revalidateOnMount ||\n            (!config.initialData && config.revalidateOnMount === undefined)) {\n            if (typeof latestKeyedData !== 'undefined' &&\n                !IS_SERVER &&\n                window['requestIdleCallback']) {\n                // delay revalidate if there's cache\n                // to not block the rendering\n                window['requestIdleCallback'](softRevalidate);\n            }\n            else {\n                softRevalidate();\n            }\n        }\n        // whenever the window gets focused, revalidate\n        var onFocus;\n        if (config.revalidateOnFocus) {\n            // throttle: avoid being called twice from both listeners\n            // and tabs being switched quickly\n            onFocus = throttle(softRevalidate, config.focusThrottleInterval);\n            if (!FOCUS_REVALIDATORS[key]) {\n                FOCUS_REVALIDATORS[key] = [onFocus];\n            }\n            else {\n                FOCUS_REVALIDATORS[key].push(onFocus);\n            }\n        }\n        // register global cache update listener\n        var onUpdate = function (shouldRevalidate, updatedData, updatedError, dedupe) {\n            if (shouldRevalidate === void 0) { shouldRevalidate = true; }\n            if (dedupe === void 0) { dedupe = true; }\n            // update hook state\n            var newState = {};\n            var needUpdate = false;\n            if (typeof updatedData !== 'undefined' &&\n                !config.compare(stateRef.current.data, updatedData)) {\n                newState.data = updatedData;\n                needUpdate = true;\n            }\n            // always update error\n            // because it can be `undefined`\n            if (stateRef.current.error !== updatedError) {\n                newState.error = updatedError;\n                needUpdate = true;\n            }\n            if (needUpdate) {\n                dispatch(newState);\n            }\n            if (shouldRevalidate) {\n                if (dedupe) {\n                    return softRevalidate();\n                }\n                else {\n                    return revalidate();\n                }\n            }\n            return false;\n        };\n        // add updater to listeners\n        if (!CACHE_REVALIDATORS[key]) {\n            CACHE_REVALIDATORS[key] = [onUpdate];\n        }\n        else {\n            CACHE_REVALIDATORS[key].push(onUpdate);\n        }\n        // set up reconnecting when the browser regains network connection\n        var reconnect = null;\n        if (!IS_SERVER && window.addEventListener && config.revalidateOnReconnect) {\n            window.addEventListener('online', (reconnect = softRevalidate));\n        }\n        return function () {\n            // cleanup\n            dispatch = function () { return null; };\n            // mark it as unmounted\n            unmountedRef.current = true;\n            if (onFocus && FOCUS_REVALIDATORS[key]) {\n                var revalidators = FOCUS_REVALIDATORS[key];\n                var index = revalidators.indexOf(onFocus);\n                if (index >= 0) {\n                    // 10x faster than splice\n                    // https://jsperf.com/array-remove-by-index\n                    revalidators[index] = revalidators[revalidators.length - 1];\n                    revalidators.pop();\n                }\n            }\n            if (CACHE_REVALIDATORS[key]) {\n                var revalidators = CACHE_REVALIDATORS[key];\n                var index = revalidators.indexOf(onUpdate);\n                if (index >= 0) {\n                    revalidators[index] = revalidators[revalidators.length - 1];\n                    revalidators.pop();\n                }\n            }\n            if (!IS_SERVER && window.removeEventListener && reconnect !== null) {\n                window.removeEventListener('online', reconnect);\n            }\n        };\n    }, [key, revalidate]);\n    // set up polling\n    useIsomorphicLayoutEffect(function () {\n        var timer = null;\n        var tick = function () { return __awaiter(_this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!(!stateRef.current.error &&\n                            (config.refreshWhenHidden || isDocumentVisible()) &&\n                            (config.refreshWhenOffline || isOnline()))) return [3 /*break*/, 2];\n                        // only revalidate when the page is visible\n                        // if API request errored, we stop polling in this round\n                        // and let the error retry function handle it\n                        return [4 /*yield*/, revalidate({ dedupe: true })];\n                    case 1:\n                        // only revalidate when the page is visible\n                        // if API request errored, we stop polling in this round\n                        // and let the error retry function handle it\n                        _a.sent();\n                        _a.label = 2;\n                    case 2:\n                        if (config.refreshInterval) {\n                            timer = setTimeout(tick, config.refreshInterval);\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        }); };\n        if (config.refreshInterval) {\n            timer = setTimeout(tick, config.refreshInterval);\n        }\n        return function () {\n            if (timer)\n                clearTimeout(timer);\n        };\n    }, [\n        config.refreshInterval,\n        config.refreshWhenHidden,\n        config.refreshWhenOffline,\n        revalidate\n    ]);\n    // suspense\n    if (config.suspense) {\n        // in suspense mode, we can't return empty state\n        // (it should be suspended)\n        // try to get data and error from cache\n        var latestData = cache.get(key) || initialData;\n        var latestError = cache.get(keyErr) || initialError;\n        if (typeof latestData === 'undefined' &&\n            typeof latestError === 'undefined') {\n            // need to start the request if it hasn't\n            if (!CONCURRENT_PROMISES[key]) {\n                // trigger revalidate immediately\n                // to get the promise\n                revalidate();\n            }\n            if (CONCURRENT_PROMISES[key] &&\n                typeof CONCURRENT_PROMISES[key].then === 'function') {\n                // if it is a promise\n                throw CONCURRENT_PROMISES[key];\n            }\n            // it's a value, return it directly (override)\n            latestData = CONCURRENT_PROMISES[key];\n        }\n        if (typeof latestData === 'undefined' && latestError) {\n            // in suspense mode, throw error if there's no content\n            throw latestError;\n        }\n        // return the latest data / error from cache\n        // in case `key` has changed\n        return {\n            error: latestError,\n            data: latestData,\n            revalidate: revalidate,\n            mutate: boundMutate,\n            isValidating: stateRef.current.isValidating\n        };\n    }\n    // define returned state\n    // can be memorized since the state is a ref\n    return useMemo(function () {\n        var state = { revalidate: revalidate, mutate: boundMutate };\n        Object.defineProperties(state, {\n            error: {\n                // `key` might be changed in the upcoming hook re-render,\n                // but the previous state will stay\n                // so we need to match the latest key and data (fallback to `initialData`)\n                get: function () {\n                    stateDependencies.current.error = true;\n                    return keyRef.current === key ? stateRef.current.error : initialError;\n                },\n                enumerable: true\n            },\n            data: {\n                get: function () {\n                    stateDependencies.current.data = true;\n                    return keyRef.current === key ? stateRef.current.data : initialData;\n                },\n                enumerable: true\n            },\n            isValidating: {\n                get: function () {\n                    stateDependencies.current.isValidating = true;\n                    return stateRef.current.isValidating;\n                },\n                enumerable: true\n            }\n        });\n        return state;\n    }, [revalidate]);\n}\nvar SWRConfig = SWRConfigContext.Provider;\nexport { trigger, mutate, SWRConfig };\nexport default useSWR;\n","var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport React, { useCallback, useMemo, useState, useRef } from 'react';\nimport { cache } from './config';\n/*\nThe idea\n\nA \"Page\" component renders the content of 1 API request, it accepts an offset (in this example it's from),\nuses a SWR hook (useSWR(API + '?limit=' + limit + '&from=' + from)) and returns items (Projects).\n\nThe UI:\n      +------------------------------------------+\n      |   Projects                               |\n+------------------------------------------------------+\n|     |   +----------------+                     |     |\n|     |                                          |     |\n|     |   +------------+                         |     |\n|     |                                          |     +--> 1 Page\n|     |   +-----------------+                    |     |\n|     |                                          |     |  /projects/list?limit=4\n|     |   +---------+                            |     |\n+------------------------------------------------------+\n      |                                          |\n      |   +------------+                         |     +  /projects/list?limit=4&from=123\n      |                                          |     |\n      |   +----------------+                     |     |\n      |                                          |     |\n      |   +---------+                            |     |\n      |                                          |     |\n      |   +--------------+                       |     +\n      |                                          |\n      |   +-------------------+                  |     +  /projects/list?limit=4&from=456\n      |                                          |     |\n      |   +------------+                         |     |\n      |                                          |     |\n      |   +----------------+                     |     |\n      |                                          |     |\n      |                                          |     +\n\nThe API\n// (inside `render`)\n\nfunction App () {\n  const {\n    pages,    // an array of each page component\n    pageSWRs, // an array of SWRs of each page\n    isLoadingMore,\n    isReachingEnd,\n    isEmpty,\n    loadMore\n  } = useSWRPages(\n    'project-page', // key of this page\n\n    // ======== the actual Page component!\n    ({ offset, withSWR }) => {\n      // required: use `withSWR` to wrap your main SWR (source of your pagination API)\n      const { data } = withSWR(\n        useSWR(API + '?limit=10&from=' + offset) // request projects with offset\n      )\n      if (!data) return <Placeholder>\n      return data.projects.map(project => <Card project={project} team={team}>)\n    },\n    // ========\n\n    // a function accepts a SWR's `data`, and returns the offset of the next page (or null)\n    data => data && data.length >= 10 ? data[data.length - 1].createdAt : null,\n\n    // (optional) outside deps of your Page component. in this case it's empty\n    []\n  )\n\n  // ...\n\n  if (isEmpty) return <EmptyProjectsPage/>\n\n  return <div>\n    {pages}\n    {isReachingEnd\n      ? null\n      : <button loading={isLoadingMore} onClick={loadMore}>Load More</button>}\n  </div>\n}\n*/\nvar pageCacheMap = new Map();\nexport function useSWRPages(pageKey, pageFn, SWRToOffset, deps) {\n    if (deps === void 0) { deps = []; }\n    var pageCountKey = \"_swr_page_count_\" + pageKey;\n    var pageOffsetKey = \"_swr_page_offset_\" + pageKey;\n    var _a = useState(cache.get(pageCountKey) || 1), pageCount = _a[0], setPageCount = _a[1];\n    var _b = useState(cache.get(pageOffsetKey) || [null]), pageOffsets = _b[0], setPageOffsets = _b[1];\n    var _c = useState([]), pageSWRs = _c[0], setPageSWRs = _c[1];\n    var pageFnRef = useRef(pageFn);\n    var emptyPageRef = useRef(false);\n    // Page component (wraps `pageFn`)\n    // for performance reason we need to memorize it\n    var Page = useCallback(function (props) {\n        // render the page component\n        var dataList = pageFnRef.current(props);\n        // if dataList is [], we can assume this page is empty\n        // TODO: this API is not stable\n        if (dataList && !dataList.length) {\n            emptyPageRef.current = true;\n        }\n        else {\n            emptyPageRef.current = false;\n        }\n        return dataList;\n    }, []);\n    // Doesn't have a next page\n    var isReachingEnd = pageOffsets[pageCount] === null;\n    var isLoadingMore = pageCount === pageOffsets.length;\n    var isEmpty = isReachingEnd && pageCount === 1 && emptyPageRef.current;\n    var loadMore = useCallback(function () {\n        if (isLoadingMore || isReachingEnd)\n            return;\n        setPageCount(function (c) {\n            cache.set(pageCountKey, c + 1);\n            return c + 1;\n        });\n    }, [isLoadingMore || isReachingEnd]);\n    var _pageFn = useCallback(pageFn, deps);\n    pageFnRef.current = _pageFn;\n    var pages = useMemo(function () {\n        var getWithSWR = function (id) { return function (swr) {\n            if (!pageSWRs[id] ||\n                pageSWRs[id].data !== swr.data ||\n                pageSWRs[id].error !== swr.error ||\n                pageSWRs[id].revalidate !== swr.revalidate) {\n                // hoist side effects: setPageSWRs and setPageOffsets -- https://reactjs.org/blog/2020/02/26/react-v16.13.0.html#warnings-for-some-updates-during-render\n                setTimeout(function () {\n                    setPageSWRs(function (swrs) {\n                        var _swrs = __spreadArrays(swrs);\n                        _swrs[id] = {\n                            data: swr.data,\n                            error: swr.error,\n                            revalidate: swr.revalidate,\n                            isValidating: swr.isValidating,\n                            mutate: swr.mutate\n                        };\n                        return _swrs;\n                    });\n                    if (typeof swr.data !== 'undefined') {\n                        // set next page's offset\n                        var newPageOffset_1 = SWRToOffset(swr, id);\n                        if (pageOffsets[id + 1] !== newPageOffset_1) {\n                            setPageOffsets(function (arr) {\n                                var _arr = __spreadArrays(arr);\n                                _arr[id + 1] = newPageOffset_1;\n                                cache.set(pageOffsetKey, _arr);\n                                return _arr;\n                            });\n                        }\n                    }\n                });\n            }\n            return swr;\n        }; };\n        // render each page\n        var p = [];\n        if (!pageCacheMap.has(pageKey)) {\n            pageCacheMap.set(pageKey, []);\n        }\n        var pageCache = pageCacheMap.get(pageKey);\n        for (var i = 0; i < pageCount; ++i) {\n            if (!pageCache[i] ||\n                pageCache[i].offset !== pageOffsets[i] ||\n                pageCache[i].pageFn !== _pageFn) {\n                // when props change or at init\n                // render the page and cache it\n                pageCache[i] = {\n                    component: (React.createElement(Page, { key: \"page-\" + pageOffsets[i] + \"-\" + i, offset: pageOffsets[i], withSWR: getWithSWR(i) })),\n                    pageFn: _pageFn,\n                    offset: pageOffsets[i]\n                };\n            }\n            p.push(pageCache[i].component);\n        }\n        return p;\n    }, [_pageFn, pageCount, pageSWRs, pageOffsets, pageKey]);\n    return {\n        pages: pages,\n        pageCount: pageCount,\n        pageSWRs: pageSWRs,\n        isLoadingMore: isLoadingMore,\n        isReachingEnd: isReachingEnd,\n        isEmpty: isEmpty,\n        loadMore: loadMore\n    };\n}\n","export * from './use-swr';\nimport { default as useSWR } from './use-swr';\nexport { useSWRPages } from './use-swr-pages';\nexport { cache } from './config';\nexport default useSWR;\n"],"sourceRoot":""}